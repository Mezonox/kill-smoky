#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *  linux/kernel/fork.c#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *  Copyright (C) 1991, 1992  Linus Torvalds#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *  'fork.c' contains the help-routines for the 'fork' system call#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * (see also entry.S and others).#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Fork is rather simple, once you get the hang of it, but the memory#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * management can be a bitch. See 'mm/memory.c': 'copy_page_range()'#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/slab.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/init.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/unistd.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/module.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/vmalloc.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/completion.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/personality.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/mempolicy.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/sem.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/file.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/fdtable.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/iocontext.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/key.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/binfmts.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/mman.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/mmu_notifier.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/fs.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/nsproxy.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/capability.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/cpu.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/cgroup.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/security.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/hugetlb.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/seccomp.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/swap.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/syscalls.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/jiffies.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/futex.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/compat.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/kthread.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/task_io_accounting_ops.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/rcupdate.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/ptrace.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/mount.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/audit.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/memcontrol.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/ftrace.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/proc_fs.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/profile.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/rmap.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/ksm.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/acct.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/tsacct_kern.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/cn_proc.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/freezer.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/delayacct.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/taskstats_kern.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/random.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/tty.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/blkdev.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/fs_struct.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/magic.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/perf_event.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/posix-timers.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/user-return-notifier.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/oom.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/khugepaged.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/signalfd.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/uprobes.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/aio.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <asm/pgtable.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <asm/pgalloc.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <asm/uaccess.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <asm/mmu_context.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <asm/cacheflush.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <asm/tlbflush.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <trace/events/sched.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define CREATE_TRACE_POINTS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <trace/events/task.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Protected counters by write_lock_irq(&tasklist_lock)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
unsigned long total_forks;	/* Handle normal Linux uptimes. */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
int nr_threads;			/* The idle threads do not count.. */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
int max_threads;		/* tunable limit on nr_threads */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
DEFINE_PER_CPU(unsigned long, process_counts) = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
__cacheline_aligned DEFINE_RWLOCK(tasklist_lock);  /* outer */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_PROVE_RCU#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
int lockdep_tasklist_lock_is_held(void)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return lockdep_is_held(&tasklist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
EXPORT_SYMBOL_GPL(lockdep_tasklist_lock_is_held);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif /* #ifdef CONFIG_PROVE_RCU */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
int nr_processes(void)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int cpu;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int total = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	for_each_possible_cpu(cpu)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		total += per_cpu(process_counts, cpu);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return total;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __weak arch_release_task_struct(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct kmem_cache *task_struct_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline struct task_struct *alloc_task_struct_node(int node)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return kmem_cache_alloc_node(task_struct_cachep, GFP_KERNEL, node);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void free_task_struct(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	kmem_cache_free(task_struct_cachep, tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __weak arch_release_thread_info(struct thread_info *ti)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifndef CONFIG_ARCH_THREAD_INFO_ALLOCATOR#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Allocate pages if THREAD_SIZE is >= PAGE_SIZE, otherwise use a#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * kmemcache based allocator.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
# if THREAD_SIZE >= PAGE_SIZE#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct thread_info *alloc_thread_info_node(struct task_struct *tsk,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
						  int node)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct page *page = alloc_pages_node(node, THREADINFO_GFP_ACCOUNTED,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					     THREAD_SIZE_ORDER);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return page ? page_address(page) : NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void free_thread_info(struct thread_info *ti)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_memcg_kmem_pages((unsigned long)ti, THREAD_SIZE_ORDER);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
# else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct kmem_cache *thread_info_cache;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct thread_info *alloc_thread_info_node(struct task_struct *tsk,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
						  int node)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return kmem_cache_alloc_node(thread_info_cache, THREADINFO_GFP, node);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void free_thread_info(struct thread_info *ti)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	kmem_cache_free(thread_info_cache, ti);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void thread_info_cache_init(void)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	thread_info_cache = kmem_cache_create("thread_info", THREAD_SIZE,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					      THREAD_SIZE, 0, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	BUG_ON(thread_info_cache == NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
# endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* SLAB cache for signal_struct structures (tsk->signal) */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct kmem_cache *signal_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* SLAB cache for sighand_struct structures (tsk->sighand) */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct kmem_cache *sighand_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* SLAB cache for files_struct structures (tsk->files) */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct kmem_cache *files_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* SLAB cache for fs_struct structures (tsk->fs) */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct kmem_cache *fs_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* SLAB cache for vm_area_struct structures */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct kmem_cache *vm_area_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* SLAB cache for mm_struct structures (tsk->mm) */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct kmem_cache *mm_cachep;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void account_kernel_stack(struct thread_info *ti, int account)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct zone *zone = page_zone(virt_to_page(ti));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mod_zone_page_state(zone, NR_KERNEL_STACK, account);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void free_task(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	account_kernel_stack(tsk->stack, -1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	arch_release_thread_info(tsk->stack);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_thread_info(tsk->stack);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	rt_mutex_debug_task_free(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	ftrace_graph_exit_task(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	put_seccomp_filter(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	arch_release_task_struct(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_task_struct(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
EXPORT_SYMBOL(free_task);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void free_signal_struct(struct signal_struct *sig)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	taskstats_tgid_free(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sched_autogroup_exit(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	kmem_cache_free(signal_cachep, sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void put_signal_struct(struct signal_struct *sig)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (atomic_dec_and_test(&sig->sigcnt))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		free_signal_struct(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __put_task_struct(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	WARN_ON(!tsk->exit_state);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	WARN_ON(atomic_read(&tsk->usage));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	WARN_ON(tsk == current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_numa_free(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	security_task_free(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exit_creds(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	delayacct_tsk_free(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	put_signal_struct(tsk->signal);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!profile_handoff_task(tsk))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		free_task(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
EXPORT_SYMBOL_GPL(__put_task_struct);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __init __weak arch_task_cache_init(void) { }#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __init fork_init(unsigned long mempages)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifndef CONFIG_ARCH_TASK_STRUCT_ALLOCATOR#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifndef ARCH_MIN_TASKALIGN#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define ARCH_MIN_TASKALIGN	L1_CACHE_BYTES#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* create a slab on which task_structs can be allocated */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_struct_cachep =#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		kmem_cache_create("task_struct", sizeof(struct task_struct),#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			ARCH_MIN_TASKALIGN, SLAB_PANIC | SLAB_NOTRACK, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* do the arch specific task caches init */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	arch_task_cache_init();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * The default maximum number of threads is set to a safe#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * value: the thread structures can take up at most half#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * of memory.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	max_threads = mempages / (8 * THREAD_SIZE / PAGE_SIZE);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * we need to allow at least 20 threads to boot a system#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (max_threads < 20)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		max_threads = 20;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_task.signal->rlim[RLIMIT_NPROC].rlim_cur = max_threads/2;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_task.signal->rlim[RLIMIT_NPROC].rlim_max = max_threads/2;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_task.signal->rlim[RLIMIT_SIGPENDING] =#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		init_task.signal->rlim[RLIMIT_NPROC];#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
int __attribute__((weak)) arch_dup_task_struct(struct task_struct *dst,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					       struct task_struct *src)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	*dst = *src;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct task_struct *dup_task_struct(struct task_struct *orig)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct task_struct *tsk;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct thread_info *ti;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	unsigned long *stackend;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int node = tsk_fork_get_node(orig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int err;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk = alloc_task_struct_node(node);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	ti = alloc_thread_info_node(tsk, node);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!ti)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto free_tsk;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = arch_dup_task_struct(tsk, orig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto free_ti;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->stack = ti;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	setup_thread_stack(tsk, orig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	clear_user_return_notifier(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	clear_tsk_need_resched(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	stackend = end_of_stack(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	*stackend = STACK_END_MAGIC;	/* for overflow detection */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_CC_STACKPROTECTOR#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->stack_canary = get_random_int();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * One for us, one for whoever does the "release_task()" (usually#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * parent)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_set(&tsk->usage, 2);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_BLK_DEV_IO_TRACE#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->btrace_seq = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->splice_pipe = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->task_frag.page = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	account_kernel_stack(ti, 1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return tsk;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
free_ti:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_thread_info(ti);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
free_tsk:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_task_struct(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_MMU#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int dup_mmap(struct mm_struct *mm, struct mm_struct *oldmm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct vm_area_struct *mpnt, *tmp, *prev, **pprev;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct rb_node **rb_link, *rb_parent;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int retval;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	unsigned long charge;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	uprobe_start_dup_mmap();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	down_write(&oldmm->mmap_sem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	flush_cache_dup_mm(oldmm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	uprobe_dup_mmap(oldmm, mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Not linked in yet - no deadlock potential:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	down_write_nested(&mm->mmap_sem, SINGLE_DEPTH_NESTING);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->locked_vm = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->mmap = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->mmap_cache = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->map_count = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	cpumask_clear(mm_cpumask(mm));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->mm_rb = RB_ROOT;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	rb_link = &mm->mm_rb.rb_node;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	rb_parent = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	pprev = &mm->mmap;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = ksm_fork(mm, oldmm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = khugepaged_fork(mm, oldmm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	prev = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	for (mpnt = oldmm->mmap; mpnt; mpnt = mpnt->vm_next) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		struct file *file;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (mpnt->vm_flags & VM_DONTCOPY) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			vm_stat_account(mm, mpnt->vm_flags, mpnt->vm_file,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
							-vma_pages(mpnt));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			continue;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		charge = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (mpnt->vm_flags & VM_ACCOUNT) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			unsigned long len = vma_pages(mpnt);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (security_vm_enough_memory_mm(oldmm, len)) /* sic */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				goto fail_nomem;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			charge = len;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tmp = kmem_cache_alloc(vm_area_cachep, GFP_KERNEL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (!tmp)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			goto fail_nomem;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		*tmp = *mpnt;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		INIT_LIST_HEAD(&tmp->anon_vma_chain);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		retval = vma_dup_policy(mpnt, tmp);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			goto fail_nomem_policy;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tmp->vm_mm = mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (anon_vma_fork(tmp, mpnt))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			goto fail_nomem_anon_vma_fork;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tmp->vm_flags &= ~VM_LOCKED;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tmp->vm_next = tmp->vm_prev = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		file = tmp->vm_file;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (file) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			struct inode *inode = file_inode(file);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			struct address_space *mapping = file->f_mapping;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			get_file(file);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (tmp->vm_flags & VM_DENYWRITE)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				atomic_dec(&inode->i_writecount);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			mutex_lock(&mapping->i_mmap_mutex);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (tmp->vm_flags & VM_SHARED)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				mapping->i_mmap_writable++;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			flush_dcache_mmap_lock(mapping);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			/* insert tmp into the share list, just after mpnt */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (unlikely(tmp->vm_flags & VM_NONLINEAR))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				vma_nonlinear_insert(tmp,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
						&mapping->i_mmap_nonlinear);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				vma_interval_tree_insert_after(tmp, mpnt,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
							&mapping->i_mmap);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			flush_dcache_mmap_unlock(mapping);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			mutex_unlock(&mapping->i_mmap_mutex);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 * Clear hugetlb-related page reserves for children. This only#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 * affects MAP_PRIVATE mappings. Faults generated by the child#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 * are not guaranteed to succeed, even if read-only#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (is_vm_hugetlb_page(tmp))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			reset_vma_resv_huge_pages(tmp);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 * Link in the new vma and copy the page table entries.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		*pprev = tmp;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		pprev = &tmp->vm_next;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tmp->vm_prev = prev;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		prev = tmp;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		__vma_link_rb(mm, tmp, rb_link, rb_parent);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		rb_link = &tmp->vm_rb.rb_right;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		rb_parent = &tmp->vm_rb;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mm->map_count++;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		retval = copy_page_range(mm, oldmm, mpnt);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (tmp->vm_ops && tmp->vm_ops->open)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			tmp->vm_ops->open(tmp);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* a new mm has just been created */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	arch_dup_mmap(oldmm, mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
out:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	up_write(&mm->mmap_sem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	flush_tlb_mm(oldmm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	up_write(&oldmm->mmap_sem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	uprobe_end_dup_mmap();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return retval;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fail_nomem_anon_vma_fork:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mpol_put(vma_policy(tmp));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fail_nomem_policy:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	kmem_cache_free(vm_area_cachep, tmp);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fail_nomem:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	vm_unacct_memory(charge);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline int mm_alloc_pgd(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->pgd = pgd_alloc(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unlikely(!mm->pgd))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void mm_free_pgd(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	pgd_free(mm, mm->pgd);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define dup_mmap(mm, oldmm)	(0)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define mm_alloc_pgd(mm)	(0)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define mm_free_pgd(mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif /* CONFIG_MMU */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
__cacheline_aligned_in_smp DEFINE_SPINLOCK(mmlist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define allocate_mm()	(kmem_cache_alloc(mm_cachep, GFP_KERNEL))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define free_mm(mm)	(kmem_cache_free(mm_cachep, (mm)))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static unsigned long default_dump_filter = MMF_DUMP_FILTER_DEFAULT;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int __init coredump_filter_setup(char *s)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	default_dump_filter =#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		(simple_strtoul(s, NULL, 0) << MMF_DUMP_FILTER_SHIFT) &#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		MMF_DUMP_FILTER_MASK;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 1;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
__setup("coredump_filter=", coredump_filter_setup);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#include <linux/init_task.h>#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void mm_init_aio(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_AIO#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	spin_lock_init(&mm->ioctx_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->ioctx_table = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct mm_struct *mm_init(struct mm_struct *mm, struct task_struct *p)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_set(&mm->mm_users, 1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_set(&mm->mm_count, 1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_rwsem(&mm->mmap_sem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&mm->mmlist);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->flags = (current->mm) ?#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		(current->mm->flags & MMF_INIT_MASK) : default_dump_filter;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->core_state = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_long_set(&mm->nr_ptes, 0);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	memset(&mm->rss_stat, 0, sizeof(mm->rss_stat));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	spin_lock_init(&mm->page_table_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_init_aio(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_init_owner(mm, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	clear_tlb_flush_pending(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (likely(!mm_alloc_pgd(mm))) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mm->def_flags = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mmu_notifier_mm_init(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_mm(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void check_mm(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int i;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	for (i = 0; i < NR_MM_COUNTERS; i++) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		long x = atomic_long_read(&mm->rss_stat.count[i]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (unlikely(x))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			printk(KERN_ALERT "BUG: Bad rss-counter state "#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					  "mm:%p idx:%d val:%ld\n", mm, i, x);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	VM_BUG_ON(mm->pmd_huge_pte);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Allocate and initialize an mm_struct.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct mm_struct *mm_alloc(void)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct mm_struct *mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm = allocate_mm();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	memset(mm, 0, sizeof(*mm));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_init_cpumask(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return mm_init(mm, current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Called when the last reference to the mm#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * is dropped: either by a lazy thread or by#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * mmput. Free the page directory and the mm.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __mmdrop(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	BUG_ON(mm == &init_mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_free_pgd(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	destroy_context(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mmu_notifier_mm_destroy(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	check_mm(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_mm(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
EXPORT_SYMBOL_GPL(__mmdrop);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Decrement the use count and release all resources for an mm.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void mmput(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	might_sleep();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (atomic_dec_and_test(&mm->mm_users)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		uprobe_clear_state(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		exit_aio(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		ksm_exit(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		khugepaged_exit(mm); /* must run before exit_mmap */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		exit_mmap(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		set_mm_exe_file(mm, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (!list_empty(&mm->mmlist)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			spin_lock(&mmlist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			list_del(&mm->mmlist);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			spin_unlock(&mmlist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (mm->binfmt)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			module_put(mm->binfmt->module);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mmdrop(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
EXPORT_SYMBOL_GPL(mmput);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void set_mm_exe_file(struct mm_struct *mm, struct file *new_exe_file)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (new_exe_file)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		get_file(new_exe_file);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (mm->exe_file)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		fput(mm->exe_file);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->exe_file = new_exe_file;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct file *get_mm_exe_file(struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct file *exe_file;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* We need mmap_sem to protect against races with removal of exe_file */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	down_read(&mm->mmap_sem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exe_file = mm->exe_file;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (exe_file)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		get_file(exe_file);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	up_read(&mm->mmap_sem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return exe_file;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void dup_mm_exe_file(struct mm_struct *oldmm, struct mm_struct *newmm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* It's safe to write the exe_file pointer without exe_file_lock because#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * this is called during fork when the task is not yet in /proc */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	newmm->exe_file = get_mm_exe_file(oldmm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/**#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * get_task_mm - acquire a reference to the task's mm#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Returns %NULL if the task has no mm.  Checks PF_KTHREAD (meaning#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * this kernel workthread has transiently adopted a user mm with use_mm,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * to do its AIO) is not set and if so returns a reference to it, after#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * bumping up the use count.  User must release the mm via mmput()#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * after use.  Typically used by /proc and ptrace.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct mm_struct *get_task_mm(struct task_struct *task)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct mm_struct *mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_lock(task);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm = task->mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (mm) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (task->flags & PF_KTHREAD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			mm = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			atomic_inc(&mm->mm_users);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_unlock(task);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
EXPORT_SYMBOL_GPL(get_task_mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct mm_struct *mm_access(struct task_struct *task, unsigned int mode)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct mm_struct *mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int err;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err =  mutex_lock_killable(&task->signal->cred_guard_mutex);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return ERR_PTR(err);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm = get_task_mm(task);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (mm && mm != current->mm &&#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			!ptrace_may_access(task, mode)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mmput(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mm = ERR_PTR(-EACCES);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mutex_unlock(&task->signal->cred_guard_mutex);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void complete_vfork_done(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct completion *vfork;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_lock(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	vfork = tsk->vfork_done;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (likely(vfork)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tsk->vfork_done = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		complete(vfork);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_unlock(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int wait_for_vfork_done(struct task_struct *child,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				struct completion *vfork)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int killed;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	freezer_do_not_count();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	killed = wait_for_completion_killable(vfork);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	freezer_count();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (killed) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		task_lock(child);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		child->vfork_done = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		task_unlock(child);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	put_task_struct(child);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return killed;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/* Please note the differences between mmput and mm_release.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * mmput is called whenever we stop holding onto a mm_struct,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * error success whatever.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * mm_release is called after a mm_struct has been removed#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * from the current process.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * This difference is important for error handling, when we#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * only half set up a mm_struct for a new process and need to restore#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * the old one.  Because we mmput the new mm_struct before#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * restoring the old one. . .#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Eric Biederman 10 January 1998#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void mm_release(struct task_struct *tsk, struct mm_struct *mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* Get rid of any futexes when releasing the mm */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_FUTEX#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unlikely(tsk->robust_list)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		exit_robust_list(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tsk->robust_list = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_COMPAT#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unlikely(tsk->compat_robust_list)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		compat_exit_robust_list(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tsk->compat_robust_list = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unlikely(!list_empty(&tsk->pi_state_list)))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		exit_pi_state_list(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	uprobe_free_utask(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* Get rid of any cached register state */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	deactivate_mm(tsk, mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If we're exiting normally, clear a user-space tid field if#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * requested.  We leave this alone when dying by signal, to leave#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * the value intact in a core dump, and to save the unnecessary#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * trouble, say, a killed vfork parent shouldn't touch this mm.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Userland only wants this done for a sys_exit.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (tsk->clear_child_tid) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (!(tsk->flags & PF_SIGNALED) &&#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		    atomic_read(&mm->mm_users) > 1) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			 * We don't check the error code - if userspace has#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			 * not set up a proper pointer then tough luck.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			put_user(0, tsk->clear_child_tid);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			sys_futex(tsk->clear_child_tid, FUTEX_WAKE,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					1, NULL, NULL, 0);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tsk->clear_child_tid = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * All done, finally we can wake up parent and return this mm to him.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Also kthread_stop() uses this completion for synchronization.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (tsk->vfork_done)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		complete_vfork_done(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Allocate a new mm structure and copy contents from the#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * mm structure of the passed in task structure.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct mm_struct *dup_mm(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct mm_struct *mm, *oldmm = current->mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int err;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm = allocate_mm();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto fail_nomem;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	memcpy(mm, oldmm, sizeof(*mm));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_init_cpumask(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#if defined(CONFIG_TRANSPARENT_HUGEPAGE) && !USE_SPLIT_PMD_PTLOCKS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->pmd_huge_pte = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!mm_init(mm, tsk))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto fail_nomem;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (init_new_context(tsk, mm))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto fail_nocontext;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	dup_mm_exe_file(oldmm, mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = dup_mmap(mm, oldmm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto free_pt;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->hiwater_rss = get_mm_rss(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->hiwater_vm = mm->total_vm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (mm->binfmt && !try_module_get(mm->binfmt->module))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto free_pt;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
free_pt:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* don't put binfmt in mmput, we haven't got module yet */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->binfmt = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mmput(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fail_nomem:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fail_nocontext:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If init_new_context() failed, we cannot use mmput() to free the mm#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * because it calls destroy_context()#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_free_pgd(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_mm(mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int copy_mm(unsigned long clone_flags, struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct mm_struct *mm, *oldmm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int retval;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->min_flt = tsk->maj_flt = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->nvcsw = tsk->nivcsw = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_DETECT_HUNG_TASK#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->last_switch_count = tsk->nvcsw + tsk->nivcsw;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->mm = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->active_mm = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Are we cloning a kernel thread?#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * We need to steal a active VM for that..#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	oldmm = current->mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!oldmm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_VM) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		atomic_inc(&oldmm->mm_users);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mm = oldmm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto good_mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm = dup_mm(tsk);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto fail_nomem;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
good_mm:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->mm = mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->active_mm = mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fail_nomem:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return retval;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int copy_fs(unsigned long clone_flags, struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct fs_struct *fs = current->fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_FS) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		/* tsk->fs is already what we want */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		spin_lock(&fs->lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (fs->in_exec) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			spin_unlock(&fs->lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			return -EAGAIN;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		fs->users++;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		spin_unlock(&fs->lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->fs = copy_fs_struct(fs);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!tsk->fs)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int copy_files(unsigned long clone_flags, struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct files_struct *oldf, *newf;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int error = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * A background process may not have any files ...#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	oldf = current->files;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!oldf)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_FILES) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		atomic_inc(&oldf->count);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	newf = dup_fd(oldf, &error);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!newf)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->files = newf;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	error = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
out:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return error;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int copy_io(unsigned long clone_flags, struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_BLOCK#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct io_context *ioc = current->io_context;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct io_context *new_ioc;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!ioc)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Share io context with parent, if CLONE_IO is set#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_IO) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		ioc_task_link(ioc);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		tsk->io_context = ioc;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	} else if (ioprio_valid(ioc->ioprio)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		new_ioc = get_task_io_context(tsk, GFP_KERNEL, NUMA_NO_NODE);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (unlikely(!new_ioc))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			return -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		new_ioc->ioprio = ioc->ioprio;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		put_io_context(new_ioc);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int copy_sighand(unsigned long clone_flags, struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct sighand_struct *sig;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_SIGHAND) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		atomic_inc(&current->sighand->count);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig = kmem_cache_alloc(sighand_cachep, GFP_KERNEL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	rcu_assign_pointer(tsk->sighand, sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!sig)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_set(&sig->count, 1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	memcpy(sig->action, current->sighand->action, sizeof(sig->action));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __cleanup_sighand(struct sighand_struct *sighand)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (atomic_dec_and_test(&sighand->count)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		signalfd_cleanup(sighand);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		kmem_cache_free(sighand_cachep, sighand);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Initialize POSIX timer handling for a thread group.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void posix_cpu_timers_init_group(struct signal_struct *sig)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	unsigned long cpu_limit;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* Thread group counters. */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	thread_group_cputime_init(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	cpu_limit = ACCESS_ONCE(sig->rlim[RLIMIT_CPU].rlim_cur);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (cpu_limit != RLIM_INFINITY) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		sig->cputime_expires.prof_exp = secs_to_cputime(cpu_limit);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		sig->cputimer.running = 1;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* The timer lists. */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&sig->cpu_timers[0]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&sig->cpu_timers[1]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&sig->cpu_timers[2]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int copy_signal(unsigned long clone_flags, struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct signal_struct *sig;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_THREAD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig = kmem_cache_zalloc(signal_cachep, GFP_KERNEL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->signal = sig;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!sig)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->nr_threads = 1;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_set(&sig->live, 1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_set(&sig->sigcnt, 1);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* list_add(thread_node, thread_head) without INIT_LIST_HEAD() */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->thread_head = (struct list_head)LIST_HEAD_INIT(tsk->thread_node);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->thread_node = (struct list_head)LIST_HEAD_INIT(sig->thread_head);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_waitqueue_head(&sig->wait_chldexit);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->curr_target = tsk;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_sigpending(&sig->shared_pending);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&sig->posix_timers);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	hrtimer_init(&sig->real_timer, CLOCK_MONOTONIC, HRTIMER_MODE_REL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->real_timer.function = it_real_fn;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_lock(current->group_leader);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	memcpy(sig->rlim, current->signal->rlim, sizeof sig->rlim);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_unlock(current->group_leader);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	posix_cpu_timers_init_group(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tty_audit_fork(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sched_autogroup_fork(sig);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_CGROUPS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_rwsem(&sig->group_rwsem);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->oom_score_adj = current->signal->oom_score_adj;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->oom_score_adj_min = current->signal->oom_score_adj_min;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sig->has_child_subreaper = current->signal->has_child_subreaper ||#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				   current->signal->is_child_subreaper;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mutex_init(&sig->cred_guard_mutex);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void copy_flags(unsigned long clone_flags, struct task_struct *p)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	unsigned long new_flags = p->flags;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	new_flags &= ~(PF_SUPERPRIV | PF_WQ_WORKER);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	new_flags |= PF_FORKNOEXEC;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->flags = new_flags;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE1(set_tid_address, int __user *, tidptr)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	current->clear_child_tid = tidptr;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return task_pid_vnr(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void rt_mutex_init_task(struct task_struct *p)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	raw_spin_lock_init(&p->pi_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_RT_MUTEXES#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pi_waiters = RB_ROOT;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pi_waiters_leftmost = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pi_blocked_on = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pi_top_task = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_MM_OWNER#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void mm_init_owner(struct mm_struct *mm, struct task_struct *p)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm->owner = p;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif /* CONFIG_MM_OWNER */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Initialize POSIX timer handling for a single task.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void posix_cpu_timers_init(struct task_struct *tsk)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->cputime_expires.prof_exp = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->cputime_expires.virt_exp = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	tsk->cputime_expires.sched_exp = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&tsk->cpu_timers[0]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&tsk->cpu_timers[1]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&tsk->cpu_timers[2]);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
init_task_pid(struct task_struct *task, enum pid_type type, struct pid *pid)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 task->pids[type].pid = pid;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * This creates a new process as a copy of the old one,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * but does not actually start it yet.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * It copies the registers, and all the appropriate#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * parts of the process environment (as per the clone#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * flags). The actual kick-off is left to the caller.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static struct task_struct *copy_process(unsigned long clone_flags,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					unsigned long stack_start,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					unsigned long stack_size,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					int __user *child_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					struct pid *pid,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					int trace)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int retval;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct task_struct *p;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((clone_flags & (CLONE_NEWNS|CLONE_FS)) == (CLONE_NEWNS|CLONE_FS))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return ERR_PTR(-EINVAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((clone_flags & (CLONE_NEWUSER|CLONE_FS)) == (CLONE_NEWUSER|CLONE_FS))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return ERR_PTR(-EINVAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Thread groups must share signals as well, and detached threads#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * can only be started up within the thread group.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((clone_flags & CLONE_THREAD) && !(clone_flags & CLONE_SIGHAND))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return ERR_PTR(-EINVAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Shared signal handlers imply shared VM. By way of the above,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * thread groups also imply shared VM. Blocking this case allows#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * for various simplifications in other code.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((clone_flags & CLONE_SIGHAND) && !(clone_flags & CLONE_VM))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return ERR_PTR(-EINVAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Siblings of global init remain as zombies on exit since they are#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * not reaped by their parent (swapper). To solve this and to avoid#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * multi-rooted process trees, prevent global and container-inits#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * from creating siblings.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((clone_flags & CLONE_PARENT) &&#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				current->signal->flags & SIGNAL_UNKILLABLE)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return ERR_PTR(-EINVAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If the new process will be in a different pid or user namespace#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * do not allow it to share a thread group or signal handlers or#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * parent with the forking task.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_SIGHAND) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if ((clone_flags & (CLONE_NEWUSER | CLONE_NEWPID)) ||#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		    (task_active_pid_ns(current) !=#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				current->nsproxy->pid_ns_for_children))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			return ERR_PTR(-EINVAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = security_task_create(clone_flags);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto fork_out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p = dup_task_struct(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!p)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto fork_out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	ftrace_graph_init_task(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	get_seccomp_filter(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	rt_mutex_init_task(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_PROVE_LOCKING#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	DEBUG_LOCKS_WARN_ON(!p->hardirqs_enabled);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	DEBUG_LOCKS_WARN_ON(!p->softirqs_enabled);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = -EAGAIN;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (atomic_read(&p->real_cred->user->processes) >=#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			task_rlimit(p, RLIMIT_NPROC)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (p->real_cred->user != INIT_USER &&#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		    !capable(CAP_SYS_RESOURCE) && !capable(CAP_SYS_ADMIN))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			goto bad_fork_free;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	current->flags &= ~PF_NPROC_EXCEEDED;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_creds(p, clone_flags);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval < 0)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_free;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If multiple threads are within copy_process(), then this check#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * triggers too late. This doesn't hurt, the check is only there#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * to stop root fork bombs.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = -EAGAIN;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (nr_threads >= max_threads)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_count;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!try_module_get(task_thread_info(p)->exec_domain->module))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_count;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	delayacct_tsk_init(p);	/* Must remain after dup_task_struct() */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	copy_flags(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&p->children);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&p->sibling);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	rcu_copy_process(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->vfork_done = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	spin_lock_init(&p->alloc_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_sigpending(&p->pending);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->utime = p->stime = p->gtime = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->utimescaled = p->stimescaled = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifndef CONFIG_VIRT_CPU_ACCOUNTING_NATIVE#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->prev_cputime.utime = p->prev_cputime.stime = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_VIRT_CPU_ACCOUNTING_GEN#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	seqlock_init(&p->vtime_seqlock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->vtime_snap = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->vtime_snap_whence = VTIME_SLEEPING;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#if defined(SPLIT_RSS_COUNTING)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	memset(&p->rss_stat, 0, sizeof(p->rss_stat));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->default_timer_slack_ns = current->timer_slack_ns;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_io_accounting_init(&p->ioac);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	acct_clear_integrals(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	posix_cpu_timers_init(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	do_posix_clock_monotonic_gettime(&p->start_time);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->real_start_time = p->start_time;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	monotonic_to_bootbased(&p->real_start_time);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->io_context = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->audit_context = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_THREAD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		threadgroup_change_begin(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	cgroup_fork(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_NUMA#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->mempolicy = mpol_dup(p->mempolicy);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (IS_ERR(p->mempolicy)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		retval = PTR_ERR(p->mempolicy);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->mempolicy = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_cgroup;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mpol_fix_fork_child_flag(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_CPUSETS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->cpuset_mem_spread_rotor = NUMA_NO_NODE;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->cpuset_slab_spread_rotor = NUMA_NO_NODE;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	seqcount_init(&p->mems_allowed_seq);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_TRACE_IRQFLAGS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->irq_events = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->hardirqs_enabled = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->hardirq_enable_ip = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->hardirq_enable_event = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->hardirq_disable_ip = _THIS_IP_;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->hardirq_disable_event = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->softirqs_enabled = 1;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->softirq_enable_ip = _THIS_IP_;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->softirq_enable_event = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->softirq_disable_ip = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->softirq_disable_event = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->hardirq_context = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->softirq_context = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_LOCKDEP#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->lockdep_depth = 0; /* no locks held yet */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->curr_chain_key = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->lockdep_recursion = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_DEBUG_MUTEXES#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->blocked_on = NULL; /* not blocked yet */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_MEMCG#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->memcg_batch.do_batch = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->memcg_batch.memcg = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_BCACHE#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->sequential_io	= 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->sequential_io_avg	= 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* Perform scheduler related setup. Assign this task to a CPU. */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = sched_fork(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_policy;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = perf_event_init_task(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_policy;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = audit_alloc(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_policy;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* copy all the process information */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_semundo(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_audit;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_files(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_semundo;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_fs(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_files;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_sighand(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_signal(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_sighand;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_mm(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_signal;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_namespaces(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_mm;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_io(clone_flags, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_namespaces;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	retval = copy_thread(clone_flags, stack_start, stack_size, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (retval)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_cleanup_io;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (pid != &init_struct_pid) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		retval = -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		pid = alloc_pid(p->nsproxy->pid_ns_for_children);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (!pid)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			goto bad_fork_cleanup_io;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->set_child_tid = (clone_flags & CLONE_CHILD_SETTID) ? child_tidptr : NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Clear TID on mm_release()?#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->clear_child_tid = (clone_flags & CLONE_CHILD_CLEARTID) ? child_tidptr : NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_BLOCK#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->plug = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_FUTEX#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->robust_list = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_COMPAT#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->compat_robust_list = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&p->pi_state_list);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pi_state_cache = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * sigaltstack should be cleared when sharing the same VM#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((clone_flags & (CLONE_VM|CLONE_VFORK)) == CLONE_VM)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->sas_ss_sp = p->sas_ss_size = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Syscall tracing and stepping should be turned off in the#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * child regardless of CLONE_PTRACE.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	user_disable_single_step(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	clear_tsk_thread_flag(p, TIF_SYSCALL_TRACE);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef TIF_SYSCALL_EMU#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	clear_tsk_thread_flag(p, TIF_SYSCALL_EMU);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	clear_all_latency_tracing(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* ok, now we should be set up.. */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pid = pid_nr(pid);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_THREAD) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->exit_signal = -1;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->group_leader = current->group_leader;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->tgid = current->tgid;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	} else {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (clone_flags & CLONE_PARENT)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			p->exit_signal = current->group_leader->exit_signal;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			p->exit_signal = (clone_flags & CSIGNAL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->group_leader = p;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->tgid = p->pid;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->nr_dirtied = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->nr_dirtied_pause = 128 >> (PAGE_SHIFT - 10);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->dirty_paused_when = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->pdeath_signal = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	INIT_LIST_HEAD(&p->thread_group);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p->task_works = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Make it visible to the rest of the system, but dont wake it up yet.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Need tasklist lock for parent etc handling!#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	write_lock_irq(&tasklist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* CLONE_PARENT re-uses the old parent */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & (CLONE_PARENT|CLONE_THREAD)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->real_parent = current->real_parent;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->parent_exec_id = current->parent_exec_id;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	} else {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->real_parent = current;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		p->parent_exec_id = current->self_exec_id;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	spin_lock(&current->sighand->siglock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Process group and session signals need to be delivered to just the#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * parent before the fork or both the parent and the child after the#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * fork. Restart if a signal comes in before we add the new process to#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * it's process group.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * A fatal signal pending means that current will exit, so the new#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * thread can't slip out of an OOM kill (or normal SIGKILL).#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	*/#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	recalc_sigpending();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (signal_pending(current)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		spin_unlock(&current->sighand->siglock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		write_unlock_irq(&tasklist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		retval = -ERESTARTNOINTR;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_fork_free_pid;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (likely(p->pid)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		ptrace_init_task(p, (clone_flags & CLONE_PTRACE) || trace);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		init_task_pid(p, PIDTYPE_PID, pid);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (thread_group_leader(p)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			init_task_pid(p, PIDTYPE_PGID, task_pgrp(current));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			init_task_pid(p, PIDTYPE_SID, task_session(current));#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (is_child_reaper(pid)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				ns_of_pid(pid)->child_reaper = p;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				p->signal->flags |= SIGNAL_UNKILLABLE;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			p->signal->leader_pid = pid;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			p->signal->tty = tty_kref_get(current->signal->tty);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			list_add_tail(&p->sibling, &p->real_parent->children);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			list_add_tail_rcu(&p->tasks, &init_task.tasks);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			attach_pid(p, PIDTYPE_PGID);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			attach_pid(p, PIDTYPE_SID);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			__this_cpu_inc(process_counts);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		} else {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			current->signal->nr_threads++;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			atomic_inc(&current->signal->live);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			atomic_inc(&current->signal->sigcnt);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			list_add_tail_rcu(&p->thread_group,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					  &p->group_leader->thread_group);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			list_add_tail_rcu(&p->thread_node,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					  &p->signal->thread_head);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		attach_pid(p, PIDTYPE_PID);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		nr_threads++;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	total_forks++;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	spin_unlock(&current->sighand->siglock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	write_unlock_irq(&tasklist_lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	proc_fork_connector(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	cgroup_post_fork(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_THREAD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		threadgroup_change_end(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	perf_event_fork(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	trace_task_newtask(p, clone_flags);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	uprobe_copy_process(p, clone_flags);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return p;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_free_pid:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (pid != &init_struct_pid)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		free_pid(pid);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_io:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (p->io_context)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		exit_io_context(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_namespaces:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exit_task_namespaces(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_mm:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (p->mm)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		mmput(p->mm);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_signal:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!(clone_flags & CLONE_THREAD))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		free_signal_struct(p->signal);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_sighand:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	__cleanup_sighand(p->sighand);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_fs:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exit_fs(p); /* blocking */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_files:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exit_files(p); /* blocking */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_semundo:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exit_sem(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_audit:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	audit_free(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_policy:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	perf_event_free_task(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_NUMA#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mpol_put(p->mempolicy);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_cgroup:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (clone_flags & CLONE_THREAD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		threadgroup_change_end(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	cgroup_exit(p, 0);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	delayacct_tsk_free(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	module_put(task_thread_info(p)->exec_domain->module);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_cleanup_count:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	atomic_dec(&p->cred->user->processes);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	exit_creds(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_fork_free:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	free_task(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
fork_out:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return ERR_PTR(retval);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static inline void init_idle_pids(struct pid_link *links)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	enum pid_type type;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	for (type = PIDTYPE_PID; type < PIDTYPE_MAX; ++type) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		INIT_HLIST_NODE(&links[type].node); /* not really needed */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		links[type].pid = &init_struct_pid;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
struct task_struct *fork_idle(int cpu)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct task_struct *task;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task = copy_process(CLONE_VM, 0, 0, NULL, &init_struct_pid, 0);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!IS_ERR(task)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		init_idle_pids(task->pids);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		init_idle(task, cpu);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return task;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *  Ok, this is the main fork-routine.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * It copies the process, and if successful kick-starts#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * it and waits for it to finish using the VM if required.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
long do_fork(unsigned long clone_flags,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	      unsigned long stack_start,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	      unsigned long stack_size,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	      int __user *parent_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	      int __user *child_tidptr)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct task_struct *p;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int trace = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	long nr;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Determine whether and which event to report to ptracer.  When#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * called from kernel_thread or CLONE_UNTRACED is explicitly#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * requested, no event is reported; otherwise, report if the event#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * for the type of forking is enabled.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!(clone_flags & CLONE_UNTRACED)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (clone_flags & CLONE_VFORK)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			trace = PTRACE_EVENT_VFORK;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		else if ((clone_flags & CSIGNAL) != SIGCHLD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			trace = PTRACE_EVENT_CLONE;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			trace = PTRACE_EVENT_FORK;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (likely(!ptrace_event_enabled(current, trace)))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			trace = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	p = copy_process(clone_flags, stack_start, stack_size,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			 child_tidptr, NULL, trace);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Do this prior waking up the new thread - the thread pointer#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * might get invalid after that point, if the thread exits quickly.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!IS_ERR(p)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		struct completion vfork;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		trace_sched_process_fork(current, p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		nr = task_pid_vnr(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (clone_flags & CLONE_PARENT_SETTID)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			put_user(nr, parent_tidptr);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (clone_flags & CLONE_VFORK) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			p->vfork_done = &vfork;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			init_completion(&vfork);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			get_task_struct(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		wake_up_new_task(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		/* forking complete and child started to run, tell ptracer */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (unlikely(trace))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			ptrace_event(trace, nr);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (clone_flags & CLONE_VFORK) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (!wait_for_vfork_done(p, &vfork))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				ptrace_event(PTRACE_EVENT_VFORK_DONE, nr);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	} else {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		nr = PTR_ERR(p);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return nr;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Create a kernel thread.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
pid_t kernel_thread(int (*fn)(void *), void *arg, unsigned long flags)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return do_fork(flags|CLONE_VM|CLONE_UNTRACED, (unsigned long)fn,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		(unsigned long)arg, NULL, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef __ARCH_WANT_SYS_FORK#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE0(fork)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_MMU#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return do_fork(SIGCHLD, 0, 0, NULL, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* can not support in nommu mode */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return -EINVAL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef __ARCH_WANT_SYS_VFORK#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE0(vfork)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return do_fork(CLONE_VFORK | CLONE_VM | SIGCHLD, 0,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			0, NULL, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef __ARCH_WANT_SYS_CLONE#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifdef CONFIG_CLONE_BACKWARDS#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int __user *, parent_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int, tls_val,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int __user *, child_tidptr)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#elif defined(CONFIG_CLONE_BACKWARDS2)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE5(clone, unsigned long, newsp, unsigned long, clone_flags,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int __user *, parent_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int __user *, child_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int, tls_val)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#elif defined(CONFIG_CLONE_BACKWARDS3)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE6(clone, unsigned long, clone_flags, unsigned long, newsp,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		int, stack_size,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		int __user *, parent_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		int __user *, child_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		int, tls_val)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE5(clone, unsigned long, clone_flags, unsigned long, newsp,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int __user *, parent_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int __user *, child_tidptr,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		 int, tls_val)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return do_fork(clone_flags, newsp, 0, parent_tidptr, child_tidptr);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#ifndef ARCH_MIN_MMSTRUCT_ALIGN#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define ARCH_MIN_MMSTRUCT_ALIGN 0#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#endif#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static void sighand_ctor(void *data)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct sighand_struct *sighand = data;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	spin_lock_init(&sighand->siglock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	init_waitqueue_head(&sighand->signalfd_wqh);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
void __init proc_caches_init(void)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	sighand_cachep = kmem_cache_create("sighand_cache",#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			sizeof(struct sighand_struct), 0,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_DESTROY_BY_RCU|#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			SLAB_NOTRACK, sighand_ctor);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	signal_cachep = kmem_cache_create("signal_cache",#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			sizeof(struct signal_struct), 0,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	files_cachep = kmem_cache_create("files_cache",#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			sizeof(struct files_struct), 0,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	fs_cachep = kmem_cache_create("fs_cache",#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			sizeof(struct fs_struct), 0,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * FIXME! The "sizeof(struct mm_struct)" currently includes the#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * whole struct cpumask for the OFFSTACK case. We could change#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * this to *only* allocate as much of it as required by the#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * maximum number of CPU's we can ever have.  The cpumask_allocation#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * is at the end of the structure, exactly for that reason.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mm_cachep = kmem_cache_create("mm_struct",#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			sizeof(struct mm_struct), ARCH_MIN_MMSTRUCT_ALIGN,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			SLAB_HWCACHE_ALIGN|SLAB_PANIC|SLAB_NOTRACK, NULL);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	vm_area_cachep = KMEM_CACHE(vm_area_struct, SLAB_PANIC);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	mmap_init();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	nsproxy_cache_init();#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Check constraints on flags passed to the unshare system call.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int check_unshare_flags(unsigned long unshare_flags)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & ~(CLONE_THREAD|CLONE_FS|CLONE_NEWNS|CLONE_SIGHAND|#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				CLONE_VM|CLONE_FILES|CLONE_SYSVSEM|#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				CLONE_NEWUTS|CLONE_NEWIPC|CLONE_NEWNET|#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				CLONE_NEWUSER|CLONE_NEWPID))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return -EINVAL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * Not implemented, but pretend it works if there is nothing to#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * unshare. Note that unsharing CLONE_THREAD or CLONE_SIGHAND#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * needs to unshare vm.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & (CLONE_THREAD | CLONE_SIGHAND | CLONE_VM)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		/* FIXME: get_task_mm() increments ->mm_users */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (atomic_read(&current->mm->mm_users) > 1)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			return -EINVAL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Unshare the filesystem structure if it is being shared#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int unshare_fs(unsigned long unshare_flags, struct fs_struct **new_fsp)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct fs_struct *fs = current->fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!(unshare_flags & CLONE_FS) || !fs)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/* don't need lock here; in the worst case we'll do useless copy */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (fs->users == 1)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	*new_fsp = copy_fs_struct(fs);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (!*new_fsp)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return -ENOMEM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * Unshare file descriptor table if it is being shared#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
static int unshare_fd(unsigned long unshare_flags, struct files_struct **new_fdp)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct files_struct *fd = current->files;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int error = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if ((unshare_flags & CLONE_FILES) &&#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	    (fd && atomic_read(&fd->count) > 1)) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		*new_fdp = dup_fd(fd, &error);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (!*new_fdp)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			return error;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * unshare allows a process to 'unshare' part of the process#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * context which was originally shared using clone.  copy_*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * functions used by do_fork() cannot be used here directly#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * because they modify an inactive task_struct that is being#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * constructed. Here we are modifying the current, active,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 * task_struct.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
SYSCALL_DEFINE1(unshare, unsigned long, unshare_flags)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct fs_struct *fs, *new_fs = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct files_struct *fd, *new_fd = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct cred *new_cred = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct nsproxy *new_nsproxy = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int do_sysvsem = 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int err;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If unsharing a user namespace must also unshare the thread.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & CLONE_NEWUSER)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		unshare_flags |= CLONE_THREAD | CLONE_FS;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If unsharing a thread from a thread group, must also unshare vm.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & CLONE_THREAD)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		unshare_flags |= CLONE_VM;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If unsharing vm, must also unshare signal handlers.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & CLONE_VM)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		unshare_flags |= CLONE_SIGHAND;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * If unsharing namespace, must also unshare filesystem information.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & CLONE_NEWNS)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		unshare_flags |= CLONE_FS;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = check_unshare_flags(unshare_flags);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_unshare_out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * CLONE_NEWIPC must also detach from the undolist: after switching#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * to a new ipc namespace, the semaphore arrays from the old#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 * namespace are unreachable.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (unshare_flags & (CLONE_NEWIPC|CLONE_SYSVSEM))#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		do_sysvsem = 1;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = unshare_fs(unshare_flags, &new_fs);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_unshare_out;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = unshare_fd(unshare_flags, &new_fd);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_unshare_cleanup_fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = unshare_userns(unshare_flags, &new_cred);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_unshare_cleanup_fd;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	err = unshare_nsproxy_namespaces(unshare_flags, &new_nsproxy,#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
					 new_cred, new_fs);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (err)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		goto bad_unshare_cleanup_cred;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (new_fs || new_fd || do_sysvsem || new_cred || new_nsproxy) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (do_sysvsem) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			 * CLONE_SYSVSEM is equivalent to sys_exit().#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			exit_sem(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (new_nsproxy)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			switch_task_namespaces(current, new_nsproxy);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		task_lock(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (new_fs) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			fs = current->fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			spin_lock(&fs->lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			current->fs = new_fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			if (--fs->users)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				new_fs = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			else#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
				new_fs = fs;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			spin_unlock(&fs->lock);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (new_fd) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			fd = current->files;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			current->files = new_fd;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			new_fd = fd;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		task_unlock(current);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		if (new_cred) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			/* Install the new user namespace */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			commit_creds(new_cred);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
			new_cred = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_unshare_cleanup_cred:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (new_cred)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		put_cred(new_cred);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_unshare_cleanup_fd:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (new_fd)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		put_files_struct(new_fd);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_unshare_cleanup_fs:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (new_fs)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		free_fs_struct(new_fs);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
bad_unshare_out:#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return err;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
/*#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *	Helper to unshare the files of the current task.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *	We don't want to expose copy_files internals to#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 *	the exec layer of the kernel.#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
 */#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
int unshare_files(struct files_struct **displaced)#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
{#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct task_struct *task = current;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	struct files_struct *copy = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	int error;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	error = unshare_fd(CLONE_FILES, &copy);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	if (error || !copy) {#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		*displaced = NULL;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
		return error;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	}#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	*displaced = task->files;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_lock(task);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task->files = copy;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	task_unlock(task);#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
	return 0;#define GPIO_PSR		(mxc_gpio_hwdata->psr_reg)
}